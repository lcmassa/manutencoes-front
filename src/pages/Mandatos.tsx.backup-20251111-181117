import React, { useState, useEffect, useRef } from 'react'
import { iapFetch } from '../utils/iap-requester'

type Mandato = {
  id: string
  condominio: string
  nomeFantasia: string
  nomeResponsavel: string
  cargo: string
  dataEntrada: string
  dataSaida: string | null
  email: string
  telefone: string
  celular: string
  status: 'ativo' | 'encerrado' | 'futuro'
  observacoes?: string
}

export function Mandatos() {
  const [data, setData] = useState<Mandato[]>([])
  const [loading, setLoading] = useState(true)
  const [erro, setErro] = useState<string | null>(null)
  const [searchTerm, setSearchTerm] = useState<string>('')
  const [ordenacao, setOrdenacao] = useState<'vencimento' | 'nome'>('vencimento')
  const loadingRef = useRef(false)
  const tokenExpiredRef = useRef(false)

  useEffect(() => {
    let isMounted = true
    
    // ========== DEBUG: RASTREAMENTO DE REDIRECIONAMENTOS ==========
    const redirectLog: Array<{type: string, url: string, timestamp: string, stack?: string}> = []
    const logRedirect = (type: string, url: string) => {
      const stack = new Error().stack || ''
      redirectLog.push({
        type,
        url,
        timestamp: new Date().toISOString(),
        stack: stack.split('\n').slice(0, 10).join('\n')
      })
      console.error(`üî¥ [DEBUG-REDIRECT] ${type}:`, url)
      console.error(`üî¥ [DEBUG-REDIRECT] Stack:`, stack)
    }
    
    // Expor log globalmente para debug
    ;(window as any).__redirectLog = redirectLog
    ;(window as any).__getRedirectLog = () => {
      console.table(redirectLog)
      return redirectLog
    }
    console.log('[Mandatos] üîç DEBUG: Rastreamento de redirecionamentos ativado. Use window.__getRedirectLog() no console.')
    // ========== FIM DEBUG ==========
    
    // PROTE√á√ÉO GLOBAL: Bloquear QUALQUER redirecionamento para login
    const originalHref = window.location.href
    let lastHref = originalHref
    let lastHash = window.location.hash
    
    // Interceptar mudan√ßas de href ANTES que aconte√ßam
    const originalHrefDescriptor = Object.getOwnPropertyDescriptor(window.location, 'href')
    if (originalHrefDescriptor && originalHrefDescriptor.set) {
      const originalSetter = originalHrefDescriptor.set
      try {
        Object.defineProperty(window.location, 'href', {
          set: function(value: string) {
            logRedirect('location.href SET', value)
            if (typeof value === 'string') {
              const isLoginUrl = value.includes('login') || 
                                value.includes('auth') || 
                                value.includes('superlogica.net/u/') ||
                                value.includes('login-hml.superlogica.net') ||
                                value.includes('/login/identifier') ||
                                value.includes('/u/login')
              
              if (isLoginUrl && !value.includes('localhost:5173')) {
                console.error('[Mandatos] ‚ö†Ô∏è BLOQUEADO: Tentativa de redirecionamento para login:', value)
                console.error('[Mandatos] üîç DEBUG: Stack completo:', new Error().stack)
                if (!tokenExpiredRef.current) {
                  tokenExpiredRef.current = true
                  setErro('Redirecionamento para login bloqueado. Token pode estar expirado. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                }
                // N√£o permitir o redirecionamento
                return
              }
            }
            // Permitir redirecionamentos normais
            return originalSetter.call(window.location, value)
          },
          get: () => window.location.href,
          configurable: true
        })
      } catch (e) {
        console.warn('[Mandatos] N√£o foi poss√≠vel interceptar window.location.href:', e)
      }
    }
    
    // Interceptar location.assign
    const originalAssign = window.location.assign
    window.location.assign = function(url: string) {
      logRedirect('location.assign', url)
      if (typeof url === 'string' && (
        url.includes('login') || url.includes('auth') || url.includes('superlogica.net')
      ) && !url.includes('localhost:5173')) {
        console.error('[Mandatos] ‚ö†Ô∏è BLOQUEADO: location.assign para login:', url)
        console.error('[Mandatos] üîç DEBUG: Stack completo:', new Error().stack)
        if (!tokenExpiredRef.current) {
          tokenExpiredRef.current = true
          setErro('Redirecionamento para login bloqueado. Token pode estar expirado. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
        }
        return
      }
      return originalAssign.call(window.location, url)
    }
    
    // Interceptar location.replace
    const originalReplace = window.location.replace
    window.location.replace = function(url: string) {
      logRedirect('location.replace', url)
      if (typeof url === 'string' && (
        url.includes('login') || url.includes('auth') || url.includes('superlogica.net')
      ) && !url.includes('localhost:5173')) {
        console.error('[Mandatos] ‚ö†Ô∏è BLOQUEADO: location.replace para login:', url)
        console.error('[Mandatos] üîç DEBUG: Stack completo:', new Error().stack)
        if (!tokenExpiredRef.current) {
          tokenExpiredRef.current = true
          setErro('Redirecionamento para login bloqueado. Token pode estar expirado. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
        }
        return
      }
      return originalReplace.call(window.location, url)
    }
    
    const checkUrlChange = () => {
      const currentHref = window.location.href
      const currentHash = window.location.hash
      
      if (currentHref !== lastHref || currentHash !== lastHash) {
        const isLoginUrl = currentHref.includes('login') || 
                          currentHref.includes('auth') || 
                          currentHref.includes('superlogica.net/u/') ||
                          currentHref.includes('login-hml.superlogica.net') ||
                          currentHref.includes('/login/identifier') ||
                          currentHref.includes('/u/login')
        
        if (isLoginUrl && !currentHref.includes('localhost:5173')) {
          console.error('[Mandatos] ‚ö†Ô∏è BLOQUEADO: Redirecionamento para login detectado:', currentHref)
          // For√ßar volta para a URL original
          window.history.replaceState(null, '', lastHref || originalHref || '#/mandatos')
          if (window.location.href !== (lastHref || originalHref)) {
            window.location.href = lastHref || originalHref || '#/mandatos'
          }
          if (!tokenExpiredRef.current) {
            tokenExpiredRef.current = true
            setErro('Redirecionamento para login bloqueado. Token pode estar expirado. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
          }
          return
        }
        lastHref = currentHref
        lastHash = currentHash
      }
    }
    
    const urlCheckInterval = setInterval(checkUrlChange, 25) // Verificar mais frequentemente
    
    const handlePopState = (e: PopStateEvent) => {
      checkUrlChange()
    }
    
    const handleHashChange = () => {
      checkUrlChange()
    }
    
    window.addEventListener('popstate', handlePopState)
    window.addEventListener('hashchange', handleHashChange)
    
    // Fun√ß√£o para verificar token antes de fazer requisi√ß√µes
    const verificarTokenAntesDeCarregar = async () => {
      // Aguardar um tempo inicial para garantir que tudo est√° carregado
      // Aumentar delay para dar tempo do token ser carregado do .env
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      if (!isMounted || tokenExpiredRef.current) {
        return
      }
      
      // Verificar se h√° token no localStorage ou no ambiente
      const token = typeof window !== 'undefined' 
        ? (localStorage.getItem('iap-token') || 
           localStorage.getItem('VITE_IAP_TOKEN') ||
           (window as any).__IAP_TOKEN ||
           (import.meta as any).env?.VITE_IAP_TOKEN)
        : null
      
      if (!token) {
        console.log('[Mandatos] Nenhum token encontrado ap√≥s 2 segundos')
        setErro('Token de autentica√ß√£o n√£o encontrado. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
        setLoading(false)
        loadingRef.current = false
        return
      }
      
      // Se h√° token, fazer uma requisi√ß√£o de teste primeiro antes de mostrar modal
      console.log('[Mandatos] Token encontrado, testando validade...')
      try {
        const testResponse = await iapFetch('/api/user/', {
          headers: {
            'x-company-id': localStorage.getItem('x-company-id') || '',
            'company-id': localStorage.getItem('x-company-id') || '',
          }
        })
        
        if (testResponse.status === 401 || testResponse.status === 403) {
          console.log('[Mandatos] Token inv√°lido ou expirado')
          setErro('Token de autentica√ß√£o expirado ou inv√°lido. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
          setLoading(false)
          loadingRef.current = false
          return
        }
        
        // Token v√°lido, carregar dados
        console.log('[Mandatos] Token v√°lido, carregando dados...')
        if (!tokenExpiredRef.current) {
          carregarMandatos()
        }
      } catch (e: any) {
        // Se der erro na verifica√ß√£o, tentar carregar mesmo assim
        // (pode ser erro de rede, n√£o necessariamente token inv√°lido)
        console.warn('[Mandatos] Erro ao verificar token, tentando carregar dados mesmo assim:', e.message)
        if (!tokenExpiredRef.current) {
          carregarMandatos()
        }
      }
    }
    
    // Executar verifica√ß√£o ap√≥s delay inicial
    verificarTokenAntesDeCarregar()
    
    // Listener para eventos de token expirado
    const handleTokenExpired = (event: CustomEvent) => {
      if (isMounted && !loadingRef.current) {
        console.log('[Mandatos] Evento de token expirado recebido')
        setErro('Token de autentica√ß√£o expirado. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
        setLoading(false)
        loadingRef.current = false
      }
    }
    
    window.addEventListener('iap-token-expired', handleTokenExpired as EventListener)
    
    return () => {
      isMounted = false
      window.removeEventListener('iap-token-expired', handleTokenExpired as EventListener)
      window.removeEventListener('popstate', handlePopState)
      window.removeEventListener('hashchange', handleHashChange)
      if (urlCheckInterval) {
        clearInterval(urlCheckInterval)
      }
      // Restaurar m√©todos originais
      if (originalHrefDescriptor && originalHrefDescriptor.set) {
        try {
          Object.defineProperty(window.location, 'href', {
            set: originalHrefDescriptor.set,
            get: () => window.location.href,
            configurable: true
          })
        } catch (e) {
          // Ignorar erro ao restaurar
        }
      }
      if (originalAssign) {
        window.location.assign = originalAssign
      }
      if (originalReplace) {
        window.location.replace = originalReplace
      }
    }
  }, [])

  const carregarMandatos = async () => {
    // Evita m√∫ltiplas requisi√ß√µes simult√¢neas
    if (loadingRef.current) {
      console.log('[Mandatos] Requisi√ß√£o j√° em andamento, ignorando...')
      return
    }
    
    // Se j√° detectamos token expirado, n√£o tenta novamente automaticamente
    if (tokenExpiredRef.current) {
      console.log('[Mandatos] Token expirado detectado anteriormente, ignorando requisi√ß√£o autom√°tica...')
      return
    }
    
    console.log('[Mandatos] ========== INICIANDO CARREGAMENTO DE MANDATOS ==========')
    console.log('[Mandatos] Timestamp:', new Date().toISOString())
    
    loadingRef.current = true
    setLoading(true)
    setErro(null)
    try {
      const companyId = typeof window !== 'undefined' ? localStorage.getItem('x-company-id') : null
      console.log('[Mandatos] Company ID do localStorage:', companyId)
      
      // Fun√ß√£o auxiliar para fazer requisi√ß√£o de uma p√°gina espec√≠fica
      const fazerRequisicaoPagina = async (comStatus: string, pagina: number = 1): Promise<{ list: any[], totalPaginas?: number, totalItens?: number }> => {
        const params = new URLSearchParams({
          itensPorPagina: '50', // API recomenda no m√°ximo 50 (conforme Postman)
          pagina: String(pagina),
        })
        
        // S√≥ adiciona comStatus se n√£o for vazio (string vazia significa buscar todos sem filtro)
        if (comStatus && comStatus.trim() !== '') {
          params.append('comStatus', comStatus.trim())
        }
        
        const url = `/api/condominios/superlogica/sindicos?${params.toString()}`
        const statusLabel = comStatus && comStatus.trim() !== '' ? comStatus : 'todos (sem filtro)'
        console.log(`[Mandatos] Buscando ${statusLabel} p√°gina ${pagina} na URL:`, url)
        
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout: A requisi√ß√£o demorou mais de 60 segundos.')), 60000)
        )
        
        const fetchPromise = iapFetch(url, {
          headers: companyId ? {
            'x-company-id': companyId,
            'company-id': companyId,
          } : undefined,
        })
        
        const res = await Promise.race([fetchPromise, timeoutPromise]) as Response
        
        if (!res.ok) {
          let errorText = 'Erro desconhecido'
          try {
            const errorData = await res.json().catch(() => null)
            if (errorData) {
              errorText = typeof errorData === 'string' ? errorData : JSON.stringify(errorData)
              // Tentar extrair mensagem de erro mais espec√≠fica
              if (errorData.detail) errorText = errorData.detail
              else if (errorData.message) errorText = errorData.message
              else if (errorData.error) errorText = errorData.error
            } else {
              errorText = await res.text().catch(() => 'Erro desconhecido')
            }
          } catch {
            errorText = await res.text().catch(() => 'Erro desconhecido')
          }
          
          let errorMessage = `HTTP ${res.status}: ${errorText}`
          
          if (res.status === 401) {
            tokenExpiredRef.current = true
            throw new Error(errorMessage)
          } else if (res.status === 422) {
            // Erro 422: log detalhado do erro mas n√£o lan√ßar exce√ß√£o
            // Retornar lista vazia para permitir que o c√≥digo continue
            console.error(`[Mandatos] Erro 422 detalhado:`, {
              url,
              status: res.status,
              errorText,
              headers: Object.fromEntries(res.headers.entries())
            })
            console.warn(`[Mandatos] Retornando lista vazia devido ao erro 422`)
            return { list: [], totalPaginas: 0, totalItens: 0 }
          }
          
          throw new Error(errorMessage)
        }
        
        const responseData = await res.json().catch(() => [])
        
        // Log detalhado da resposta da API
        console.log(`[Mandatos] Resposta da API (p√°gina ${pagina}, ${comStatus || 'sem filtro'}):`, {
          tipo: Array.isArray(responseData) ? 'array' : typeof responseData,
          keys: typeof responseData === 'object' && responseData !== null ? Object.keys(responseData) : [],
          preview: Array.isArray(responseData) 
            ? `Array com ${responseData.length} itens` 
            : typeof responseData === 'object' && responseData !== null
            ? JSON.stringify(responseData).substring(0, 200)
            : String(responseData).substring(0, 200)
        })
        
        // Log completo da estrutura da resposta para debug
        if (typeof responseData === 'object' && responseData !== null && !Array.isArray(responseData)) {
          console.log(`[Mandatos] Estrutura completa da resposta (p√°gina ${pagina}):`, {
            status: responseData.status,
            session: responseData.session,
            msg: responseData.msg,
            dataLength: Array.isArray(responseData.data) ? responseData.data.length : 'n√£o √© array',
            totalPaginas: responseData.totalPaginas,
            totalItens: responseData.totalItens,
            total: responseData.total,
            executiontime: responseData.executiontime,
            todasAsChaves: Object.keys(responseData)
          })
        }
        
        // Extrair lista de dados
        let list: any[] = []
        let totalPaginas: number | undefined
        let totalItens: number | undefined
        
        if (Array.isArray(responseData)) {
          list = responseData
        } else if (responseData?.data && Array.isArray(responseData.data)) {
          list = responseData.data
          // Tentar extrair informa√ß√µes de pagina√ß√£o
          if (responseData.totalPaginas !== undefined) totalPaginas = responseData.totalPaginas
          if (responseData.totalItens !== undefined) totalItens = responseData.totalItens
          if (responseData.total !== undefined) totalItens = responseData.total
        } else if (responseData?.sindicos && Array.isArray(responseData.sindicos)) {
          list = responseData.sindicos
        } else if (responseData?.result && Array.isArray(responseData.result)) {
          list = responseData.result
        } else if (typeof responseData === 'object' && responseData !== null) {
          const keys = Object.keys(responseData)
          for (const key of keys) {
            if (Array.isArray(responseData[key])) {
              list = responseData[key]
              console.log(`[Mandatos] Lista encontrada na chave "${key}" com ${list.length} itens`)
              break
            }
          }
          // Tentar extrair informa√ß√µes de pagina√ß√£o
          if (responseData.totalPaginas !== undefined) totalPaginas = responseData.totalPaginas
          if (responseData.totalItens !== undefined) totalItens = responseData.totalItens
          if (responseData.total !== undefined) totalItens = responseData.total
        }
        
        // Log detalhado dos condom√≠nios √∫nicos nesta p√°gina
        if (list.length > 0) {
          const condominiosUnicos = new Set(list.map((item: any) => 
            item.st_nome_cond || item.ST_NOME_COND || item.condominio || 'Sem nome'
          ))
          console.log(`[Mandatos] P√°gina ${pagina}: ${list.length} itens, ${condominiosUnicos.size} condom√≠nios √∫nicos:`, Array.from(condominiosUnicos))
        } else {
          console.log(`[Mandatos] P√°gina ${pagina}: Nenhum item retornado`)
        }
        
        return { list, totalPaginas, totalItens }
      }
      
      // Fun√ß√£o para buscar todas as p√°ginas de um status
      const fazerRequisicaoCompleta = async (comStatus: string): Promise<any[]> => {
        let todasPaginas: any[] = []
        let paginaAtual = 1
        let temMaisPaginas = true
        let totalPaginasConhecido: number | undefined
        let itensPorPagina = 50 // Valor usado na requisi√ß√£o (API recomenda m√°ximo 50)
        
        while (temMaisPaginas) {
          const resultado = await fazerRequisicaoPagina(comStatus, paginaAtual)
          todasPaginas = todasPaginas.concat(resultado.list)
          
          const statusLabel = comStatus && comStatus.trim() !== '' ? comStatus : 'todos'
          console.log(`[Mandatos] ${statusLabel} p√°gina ${paginaAtual}: ${resultado.list.length} itens`)
          
          // Se a API retornou informa√ß√£o de total de p√°ginas, usar isso
          if (resultado.totalPaginas !== undefined) {
            totalPaginasConhecido = resultado.totalPaginas
            temMaisPaginas = paginaAtual < totalPaginasConhecido
            console.log(`[Mandatos] ${statusLabel} total de p√°ginas conhecido: ${totalPaginasConhecido}`)
          } else if (resultado.totalItens !== undefined) {
            // Calcular total de p√°ginas baseado no total de itens
            const calculado = Math.ceil(resultado.totalItens / itensPorPagina)
            if (totalPaginasConhecido === undefined || calculado > totalPaginasConhecido) {
              totalPaginasConhecido = calculado
            }
            temMaisPaginas = totalPaginasConhecido !== undefined && paginaAtual < totalPaginasConhecido
            console.log(`[Mandatos] ${statusLabel} total de itens: ${resultado.totalItens}, p√°ginas calculadas: ${totalPaginasConhecido}`)
          } else {
            // Caso contr√°rio, continuar enquanto houver itens na p√°gina atual
            // IMPORTANTE: Continuar mesmo se retornou menos que itensPorPagina
            // porque a API pode estar retornando dados de forma paginada mesmo com menos itens
            temMaisPaginas = resultado.list.length > 0
            
            // Se retornou exatamente itensPorPagina, provavelmente h√° mais p√°ginas
            if (resultado.list.length === itensPorPagina) {
              temMaisPaginas = true
              console.log(`[Mandatos] ${statusLabel} p√°gina ${paginaAtual} retornou ${resultado.list.length} itens (m√°ximo), continuando...`)
            } else if (resultado.list.length > 0 && resultado.list.length < itensPorPagina) {
              // Retornou menos que o m√°ximo, mas ainda h√° itens
              // Tentar mais uma p√°gina para ter certeza
              console.log(`[Mandatos] ${statusLabel} p√°gina ${paginaAtual} retornou ${resultado.list.length} itens (menos que m√°ximo), tentando pr√≥xima p√°gina...`)
              temMaisPaginas = true
            }
          }
          
          // Limite de seguran√ßa: aumentar para 200 p√°ginas (68 condom√≠nios podem precisar de v√°rias p√°ginas)
          if (paginaAtual >= 200) {
            console.warn(`[Mandatos] Limite de 200 p√°ginas atingido para ${statusLabel}`)
            break
          }
          
          // Se n√£o retornou itens, parar
          if (resultado.list.length === 0) {
            console.log(`[Mandatos] ${statusLabel} p√°gina ${paginaAtual} retornou 0 itens, parando pagina√ß√£o`)
            temMaisPaginas = false
          }
          
          paginaAtual++
        }
        
        const statusLabel = comStatus && comStatus.trim() !== '' ? comStatus : 'todos'
        const condominiosUnicos = new Set(todasPaginas.map((item: any) => 
          item.st_nome_cond || item.ST_NOME_COND || item.condominio || 'Sem nome'
        ))
        console.log(`[Mandatos] ${statusLabel} total: ${todasPaginas.length} itens de ${paginaAtual - 1} p√°gina(s)`)
        console.log(`[Mandatos] ${statusLabel} condom√≠nios √∫nicos encontrados: ${condominiosUnicos.size}`)
        if (condominiosUnicos.size > 0) {
          console.log(`[Mandatos] ${statusLabel} lista de condom√≠nios:`, Array.from(condominiosUnicos).slice(0, 10))
        }
        return todasPaginas
      }
      
      // A API retorna apenas um condom√≠nio quando n√£o h√° idCondominio
      // Solu√ß√£o: buscar todos os condom√≠nios primeiro, depois buscar respons√°veis legais de cada um
      let todasListas: any[] = []
      
      // Primeiro, buscar lista de todos os condom√≠nios
      console.log('[Mandatos] ========== INICIANDO BUSCA DE CONDOM√çNIOS ==========')
      console.log('[Mandatos] Company ID:', companyId)
      let condominiosIds: string[] = []
      
      // Tentar buscar condom√≠nios com pagina√ß√£o completa
      const estrategiasCondominios = [
        { base: '/api/condominios/superlogica/condominios/get?id=-1&somenteCondominiosAtivos=1&ignorarCondominioModelo=1&apenasColunasPrincipais=1', itensPorPagina: 50 },
        { base: '/api/condominios/superlogica/condominios/get?id=-1&somenteCondominiosAtivos=1&ignorarCondominioModelo=1', itensPorPagina: 50 },
        { base: '/api/condominios/superlogica/condominios/get?id=-1&somenteCondominiosAtivos=1', itensPorPagina: 50 },
        { base: '/api/condominios/superlogica/condominios/get?id=-1', itensPorPagina: 50 },
      ]
      
      let condominiosEncontrados = false
      let todasListasCondominios: any[] = []
      
      for (const estrategia of estrategiasCondominios) {
        try {
          console.log('[Mandatos] Tentando estrat√©gia:', estrategia.base)
          let pagina = 1
          let temMaisPaginas = true
          let tentativasFalhadas = 0
          const maxTentativasFalhadas = 3
          const listCondominiosEstrategia: any[] = []
          
          while (temMaisPaginas && tentativasFalhadas < maxTentativasFalhadas) {
            try {
              const urlCondominios = `${estrategia.base}&itensPorPagina=${estrategia.itensPorPagina}&pagina=${pagina}`
              console.log(`[Mandatos] Buscando p√°gina ${pagina} de condom√≠nios...`)
              const resCondominios = await iapFetch(urlCondominios, {
                headers: companyId ? {
                  'x-company-id': companyId,
                  'company-id': companyId,
                } : undefined,
              })
              
              if (resCondominios.ok) {
                console.log('[Mandatos] ‚úÖ Busca de condom√≠nios bem-sucedida')
                condominiosEncontrados = true
                tentativasFalhadas = 0
                
                // Verificar se a resposta √© HTML (p√°gina de login) em vez de JSON
                const contentType = resCondominios.headers.get('content-type') || ''
                const responseText = await resCondominios.clone().text().catch(() => '')
                const isHtml = contentType.includes('text/html')
                const isLoginPage = isHtml && (
                  responseText.includes('login') || 
                  responseText.includes('Login') || 
                  responseText.includes('superlogica.net/u/login') ||
                  responseText.includes('login-hml.superlogica.net') ||
                  (responseText.includes('email') && responseText.includes('password') && responseText.includes('form'))
                )
                
                if (isLoginPage || (isHtml && responseText.length > 0)) {
                  console.error('[Mandatos] A API retornou HTML (p√°gina de login) em vez de JSON.')
                  // Mostrar modal de login imediatamente
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                  throw new Error('Token de autentica√ß√£o expirado ou inv√°lido.')
                }
                
                const dataCondominios = await resCondominios.json().catch((err) => {
                  console.error('[Mandatos] Erro ao fazer parse JSON:', err)
                  if (responseText && (responseText.includes('login') || responseText.includes('Login'))) {
                    throw new Error('Token de autentica√ß√£o expirado ou inv√°lido.')
                  }
                  return []
                })
                
                const listCondominios = Array.isArray(dataCondominios) ? dataCondominios : dataCondominios?.data || dataCondominios?.condominios || []
                
                if (listCondominios.length > 0) {
                  listCondominiosEstrategia.push(...listCondominios)
                  console.log(`[Mandatos] P√°gina ${pagina}: ${listCondominios.length} condom√≠nios, total acumulado: ${listCondominiosEstrategia.length}`)
                  
                  // Se retornou menos que o m√°ximo, n√£o h√° mais p√°ginas
                  if (listCondominios.length < estrategia.itensPorPagina) {
                    console.log(`[Mandatos] √öltima p√°gina encontrada (${listCondominios.length} < ${estrategia.itensPorPagina} itens)`)
                    temMaisPaginas = false
                  } else {
                    pagina++
                  }
                } else {
                  console.log(`[Mandatos] P√°gina ${pagina}: 0 itens - parando`)
                  temMaisPaginas = false
                }
              } else if (resCondominios.status === 401 || resCondominios.status === 403) {
                console.warn(`[Mandatos] Erro de autentica√ß√£o (${resCondominios.status}) ao buscar p√°gina ${pagina} de condom√≠nios`)
                // Mostrar modal de login imediatamente
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                temMaisPaginas = false
              } else if (resCondominios.status === 422) {
                console.warn(`[Mandatos] Erro 422 ao buscar p√°gina ${pagina} de condom√≠nios`)
                tentativasFalhadas++
                if (tentativasFalhadas >= maxTentativasFalhadas) {
                  temMaisPaginas = false
                } else {
                  pagina++
                }
              } else {
                console.warn(`[Mandatos] ‚ö†Ô∏è URL falhou com status ${resCondominios.status}, tentando pr√≥xima estrat√©gia...`)
                temMaisPaginas = false
              }
            } catch (e: any) {
              console.warn(`[Mandatos] ‚ö†Ô∏è Erro ao buscar p√°gina ${pagina}:`, e.message)
              tentativasFalhadas++
              if (tentativasFalhadas >= maxTentativasFalhadas) {
                temMaisPaginas = false
              } else {
                pagina++
              }
            }
          }
          
          if (listCondominiosEstrategia.length > 0) {
            todasListasCondominios = listCondominiosEstrategia
            console.log(`[Mandatos] ‚úÖ Estrat√©gia bem-sucedida: ${listCondominiosEstrategia.length} condom√≠nios encontrados`)
            break
          }
        } catch (e: any) {
          console.warn(`[Mandatos] ‚ö†Ô∏è Erro na estrat√©gia:`, e.message)
          // Continuar para pr√≥xima estrat√©gia
        }
      }
      
      if (todasListasCondominios.length > 0) {
        console.log('[Mandatos] Primeiro condom√≠nio (exemplo):', {
          id_condominio_cond: todasListasCondominios[0].id_condominio_cond,
          ID_CONDOMINIO_COND: todasListasCondominios[0].ID_CONDOMINIO_COND,
          id: todasListasCondominios[0].id,
          fl_ativo_cond: todasListasCondominios[0].fl_ativo_cond,
          FL_ATIVO_COND: todasListasCondominios[0].FL_ATIVO_COND,
          todasChaves: Object.keys(todasListasCondominios[0])
        })
        
        // Filtrar apenas condom√≠nios ativos
        const condominiosAtivos = todasListasCondominios.filter((c: any) => {
          const flAtivo = c.fl_ativo_cond || c.FL_ATIVO_COND || c.fl_ativo || c.FL_ATIVO
          if (flAtivo === undefined || flAtivo === null || flAtivo === '') return true
          const flAtivoStr = String(flAtivo)
          return flAtivoStr === '1' || flAtivoStr === 'true' || flAtivoStr === 'True'
        })
        
        console.log(`[Mandatos] Condom√≠nios ativos: ${todasListasCondominios.length} -> ${condominiosAtivos.length} (filtrados)`)
        
        condominiosIds = condominiosAtivos
          .map((c: any) => String(c.id_condominio_cond || c.ID_CONDOMINIO_COND || c.id))
          .filter((id: string) => id && id !== 'undefined' && id !== 'null')
        
        console.log(`[Mandatos] ‚úÖ ${condominiosIds.length} IDs de condom√≠nios extra√≠dos`)
        if (condominiosIds.length > 0) {
          console.log('[Mandatos] Primeiros 10 IDs:', condominiosIds.slice(0, 10))
        }
      }
      
      // Se n√£o encontrou condom√≠nios com nenhuma estrat√©gia, usar fallback
      if (!condominiosEncontrados && condominiosIds.length === 0) {
        console.warn('[Mandatos] ‚ö†Ô∏è Nenhuma estrat√©gia de busca de condom√≠nios funcionou, usando fallback...')
      }
      
      console.log('[Mandatos] ========== RESULTADO DA BUSCA DE CONDOM√çNIOS ==========')
      console.log('[Mandatos] Total de IDs encontrados:', condominiosIds.length)
      
      // Se encontrou condom√≠nios, buscar respons√°veis legais de cada um
      if (condominiosIds.length > 0) {
        console.log(`[Mandatos] Buscando respons√°veis legais para ${condominiosIds.length} condom√≠nios...`)
        
        // Buscar em lotes para n√£o sobrecarregar a API
        const lotes = []
        for (let i = 0; i < condominiosIds.length; i += 10) {
          lotes.push(condominiosIds.slice(i, i + 10))
        }
        
        for (const lote of lotes) {
          const promessas = lote.map(async (idCond: string) => {
            try {
              // Buscar 'atuais' e 'passado' para este condom√≠nio
              const resultados: any[] = []
              
              for (const status of ['atuais', 'passado']) {
                try {
                  const params = new URLSearchParams({
                    idCondominio: idCond,
                    comStatus: status,
                    itensPorPagina: '50',
                    pagina: '1',
                  })
                  
                  const url = `/api/condominios/superlogica/sindicos?${params.toString()}`
                  const res = await iapFetch(url, {
                    headers: companyId ? {
                      'x-company-id': companyId,
                      'company-id': companyId,
                    } : undefined,
                  })
                  
                  // Verificar erros de autentica√ß√£o ANTES de processar
                  if (res.status === 401 || res.status === 403) {
                    console.warn(`[Mandatos] Erro de autentica√ß√£o (${res.status}) para condom√≠nio ${idCond}, status ${status}`)
                    // N√£o propagar erro para n√£o interromper o processamento dos outros condom√≠nios
                    // Mas se for o primeiro erro, mostrar mensagem
                    if (!tokenExpiredRef.current) {
                      tokenExpiredRef.current = true
                      setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                    }
                    return []
                  }
                  
                  if (res.ok) {
                    // Verificar se a resposta √© HTML (p√°gina de login) em vez de JSON
                    const contentType = res.headers.get('content-type') || ''
                    if (contentType.includes('text/html')) {
                      console.warn(`[Mandatos] Resposta HTML (login) para condom√≠nio ${idCond}, status ${status}. Pulando...`)
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                      return []
                    }
                    
                    const responseData = await res.json().catch(() => [])
                    let list: any[] = []
                    
                    if (Array.isArray(responseData)) {
                      list = responseData
                    } else if (responseData?.data && Array.isArray(responseData.data)) {
                      list = responseData.data
                    } else if (responseData?.sindicos && Array.isArray(responseData.sindicos)) {
                      list = responseData.sindicos
                    }
                    
                    resultados.push(...list)
                  } else if (res.status === 401 || res.status === 403) {
                    console.warn(`[Mandatos] Erro de autentica√ß√£o (${res.status}) para condom√≠nio ${idCond}, status ${status}`)
                    // N√£o propagar erro para n√£o interromper o processamento dos outros condom√≠nios
                  }
                } catch (e: any) {
                  console.warn(`[Mandatos] Erro ao buscar ${status} para condom√≠nio ${idCond}:`, e.message)
                }
              }
              
              return resultados
            } catch (e: any) {
              console.warn(`[Mandatos] Erro ao buscar respons√°veis legais para condom√≠nio ${idCond}:`, e.message)
              return []
            }
          })
          
          const resultadosLote = await Promise.all(promessas)
          todasListas = todasListas.concat(...resultadosLote.flat())
          
          console.log(`[Mandatos] Lote processado: ${todasListas.length} respons√°veis legais encontrados at√© agora`)
        }
        
        console.log(`[Mandatos] Total de respons√°veis legais encontrados: ${todasListas.length}`)
      } else {
        // Fallback: buscar sindicos com pagina√ß√£o completa para extrair IDs de condom√≠nios
        // Depois buscar sindicos de cada condom√≠nio individualmente
        console.log('[Mandatos] Nenhum condom√≠nio encontrado, tentando extrair IDs dos sindicos...')
        
        try {
          // Buscar sindicos com pagina√ß√£o completa para pegar todos os condom√≠nios
          const sindicosParaExtrairIds: any[] = []
          
          // Come√ßar com 'atuais' que sabemos que funciona
          console.log(`[Mandatos] Buscando sindicos com comStatus=atuais para extrair IDs de condom√≠nios...`)
          let pagina = 1
          let temMaisPaginas = true
          let tentativasFalhadas = 0
          const maxTentativasFalhadas = 3
          
          while (temMaisPaginas && tentativasFalhadas < maxTentativasFalhadas) {
            try {
              const params = new URLSearchParams({
                itensPorPagina: '50',
                pagina: String(pagina),
                comStatus: 'atuais',
              })
              
              const url = `/api/condominios/superlogica/sindicos?${params.toString()}`
              console.log(`[Mandatos] Buscando p√°gina ${pagina} de sindicos (atuais)...`)
              const res = await iapFetch(url, {
                headers: companyId ? {
                  'x-company-id': companyId,
                  'company-id': companyId,
                } : undefined,
              })
              
              // Verificar erros de autentica√ß√£o ANTES de processar
              if (res.status === 401 || res.status === 403) {
                console.warn(`[Mandatos] Erro de autentica√ß√£o (${res.status}) ao buscar p√°gina ${pagina} (atuais)`)
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                temMaisPaginas = false
                break
              }
              
              if (res.ok) {
                // Verificar se a resposta √© HTML (p√°gina de login) em vez de JSON
                const contentType = res.headers.get('content-type') || ''
                if (contentType.includes('text/html')) {
                  console.warn(`[Mandatos] Resposta HTML (login) na p√°gina ${pagina} (atuais). Pulando...`)
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                  temMaisPaginas = false
                  break
                }
                
                const responseData = await res.json().catch(() => [])
                let list: any[] = []
                
                if (Array.isArray(responseData)) {
                  list = responseData
                } else if (responseData?.data && Array.isArray(responseData.data)) {
                  list = responseData.data
                } else if (responseData?.sindicos && Array.isArray(responseData.sindicos)) {
                  list = responseData.sindicos
                }
                
                if (list.length > 0) {
                  sindicosParaExtrairIds.push(...list)
                  console.log(`[Mandatos] P√°gina ${pagina} (atuais): ${list.length} itens, total acumulado: ${sindicosParaExtrairIds.length}`)
                  tentativasFalhadas = 0 // Reset contador de falhas
                  
                  // Extrair IDs √∫nicos de condom√≠nios at√© agora
                  const idsUnicosAteAgora = new Set<string>()
                  sindicosParaExtrairIds.forEach((s: any) => {
                    const idCond = s.id_condominio_cond || s.ID_CONDOMINIO_COND || s.id_condominio_cond1 || s.ID_CONDOMINIO_COND1
                    if (idCond) {
                      idsUnicosAteAgora.add(String(idCond))
                    }
                  })
                  console.log(`[Mandatos] IDs √∫nicos de condom√≠nios encontrados at√© agora: ${idsUnicosAteAgora.size}`)
                  
                  // Se retornou menos que o m√°ximo, n√£o h√° mais p√°ginas
                  if (list.length < 50) {
                    console.log(`[Mandatos] √öltima p√°gina encontrada (${list.length} < 50 itens)`)
                    temMaisPaginas = false
                  } else {
                    pagina++
                  }
                } else {
                  console.log(`[Mandatos] P√°gina ${pagina} (atuais): 0 itens - parando`)
                  temMaisPaginas = false
                }
              } else if (res.status === 422) {
                console.warn(`[Mandatos] Erro 422 ao buscar p√°gina ${pagina} (atuais)`)
                tentativasFalhadas++
                if (tentativasFalhadas >= maxTentativasFalhadas) {
                  console.warn(`[Mandatos] Muitas tentativas falhadas (${tentativasFalhadas}), parando busca de p√°ginas`)
                  temMaisPaginas = false
                } else {
                  // Tentar pr√≥xima p√°gina mesmo com 422 (√†s vezes funciona)
                  pagina++
                }
              } else {
                console.warn(`[Mandatos] Erro ${res.status} ao buscar p√°gina ${pagina} (atuais)`)
                tentativasFalhadas++
                if (tentativasFalhadas >= maxTentativasFalhadas) {
                  temMaisPaginas = false
                } else {
                  pagina++
                }
              }
            } catch (e: any) {
              const errorMsg = e?.message || String(e)
              console.warn(`[Mandatos] Erro ao buscar p√°gina ${pagina} (atuais):`, errorMsg)
              
              // Verificar se √© erro de autentica√ß√£o
              if (errorMsg.includes('401') || errorMsg.includes('403') || errorMsg.includes('Unauthorized') || errorMsg.includes('expirado') || errorMsg.includes('expired') || errorMsg.includes('autentica√ß√£o')) {
                console.warn(`[Mandatos] Erro de autentica√ß√£o detectado no catch, mostrando modal`)
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                temMaisPaginas = false
                break
              }
              
              tentativasFalhadas++
              if (tentativasFalhadas >= maxTentativasFalhadas) {
                temMaisPaginas = false
              } else {
                pagina++
              }
            }
          }
          
          console.log(`[Mandatos] Total de sindicos encontrados para extrair IDs: ${sindicosParaExtrairIds.length}`)
          
          // Extrair IDs √∫nicos de condom√≠nios dos sindicos
          const idsCondominiosUnicos = new Set<string>()
          sindicosParaExtrairIds.forEach((s: any) => {
            const idCond = s.id_condominio_cond || s.ID_CONDOMINIO_COND || s.id_condominio_cond1 || s.ID_CONDOMINIO_COND1
            if (idCond) {
              idsCondominiosUnicos.add(String(idCond))
            }
          })
          
          const idsArray = Array.from(idsCondominiosUnicos)
          console.log(`[Mandatos] ‚úÖ ${idsArray.length} IDs √∫nicos de condom√≠nios extra√≠dos dos sindicos`)
          
          if (idsArray.length > 0) {
            console.log('[Mandatos] Primeiros 5 IDs extra√≠dos:', idsArray.slice(0, 5))
            
            // Agora buscar sindicos de cada condom√≠nio individualmente
            console.log(`[Mandatos] Buscando sindicos para ${idsArray.length} condom√≠nios...`)
            
            const lotes = []
            for (let i = 0; i < idsArray.length; i += 10) {
              lotes.push(idsArray.slice(i, i + 10))
            }
            
            for (const lote of lotes) {
              const promessas = lote.map(async (idCond: string) => {
                try {
                  const resultados: any[] = []
                  
                  for (const status of ['atuais', 'passado']) {
                    try {
                      const params = new URLSearchParams({
                        idCondominio: idCond,
                        comStatus: status,
                        itensPorPagina: '50',
                        pagina: '1',
                      })
                      
                      const url = `/api/condominios/superlogica/sindicos?${params.toString()}`
                      const res = await iapFetch(url, {
                        headers: companyId ? {
                          'x-company-id': companyId,
                          'company-id': companyId,
                        } : undefined,
                      })
                      
                      // Verificar erros de autentica√ß√£o ANTES de processar
                      if (res.status === 401 || res.status === 403) {
                        console.warn(`[Mandatos] Erro de autentica√ß√£o (${res.status}) para condom√≠nio ${idCond}, status ${status}`)
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                        return []
                      }
                      
                      if (res.ok) {
                        // Verificar se a resposta √© HTML (p√°gina de login) em vez de JSON
                        const contentType = res.headers.get('content-type') || ''
                        if (contentType.includes('text/html')) {
                          console.warn(`[Mandatos] Resposta HTML (login) para condom√≠nio ${idCond}, status ${status}. Pulando...`)
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
                          return []
                        }
                        
                        const responseData = await res.json().catch(() => [])
                        let list: any[] = []
                        
                        if (Array.isArray(responseData)) {
                          list = responseData
                        } else if (responseData?.data && Array.isArray(responseData.data)) {
                          list = responseData.data
                        } else if (responseData?.sindicos && Array.isArray(responseData.sindicos)) {
                          list = responseData.sindicos
                        }
                        
                        resultados.push(...list)
                      }
                    } catch (e: any) {
                      console.warn(`[Mandatos] Erro ao buscar ${status} para condom√≠nio ${idCond}:`, e.message)
                    }
                  }
                  
                  return resultados
                } catch (e: any) {
                  console.warn(`[Mandatos] Erro ao buscar sindicos para condom√≠nio ${idCond}:`, e.message)
                  return []
                }
              })
              
              const resultadosLote = await Promise.all(promessas)
              todasListas = todasListas.concat(...resultadosLote.flat())
              
              console.log(`[Mandatos] Lote processado: ${todasListas.length} sindicos encontrados at√© agora`)
            }
          } else {
            // Se n√£o conseguiu extrair IDs, usar os sindicos encontrados diretamente
            console.warn('[Mandatos] N√£o foi poss√≠vel extrair IDs de condom√≠nios, usando sindicos encontrados diretamente')
            todasListas = sindicosParaExtrairIds
          }
        } catch (e: any) {
          const errorMsg = e?.message || String(e)
          console.warn('[Mandatos] Erro ao buscar sindicos para extrair IDs:', errorMsg)
          
          // Verificar se √© erro de autentica√ß√£o
          if (errorMsg.includes('401') || errorMsg.includes('403') || errorMsg.includes('Unauthorized') || errorMsg.includes('expirado') || errorMsg.includes('expired') || errorMsg.includes('autentica√ß√£o')) {
            console.warn(`[Mandatos] Erro de autentica√ß√£o detectado no catch do fallback, mostrando modal`)
                      if (!tokenExpiredRef.current) {
                        tokenExpiredRef.current = true
                        setErro('Erro de autentica√ß√£o. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
                      }
            // N√£o propagar o erro, apenas mostrar o modal
            return
          }
        }
      }
      
      console.log('[Mandatos] ========== RESUMO FINAL ==========')
      console.log('[Mandatos] Lista total combinada:', todasListas.length, 'itens')
      if (todasListas.length > 0) {
        console.log('[Mandatos] Primeiros itens da lista:', todasListas.slice(0, 3))
      } else {
        console.warn('[Mandatos] ‚ö†Ô∏è NENHUM ITEM ENCONTRADO! Verifique:')
        console.warn('[Mandatos]   1. Se a busca de condom√≠nios funcionou')
        console.warn('[Mandatos]   2. Se a busca de respons√°veis legais retornou dados')
        console.warn('[Mandatos]   3. Se h√° erros 422 nas requisi√ß√µes')
      }
      
      // Mapear os dados da API para o formato Mandato
      const hoje = new Date()
      hoje.setHours(0, 0, 0, 0)
      
      // Log detalhado dos dados recebidos
      console.log('Itens recebidos da API:', todasListas.length)
      if (todasListas.length > 0) {
        todasListas.slice(0, 5).forEach((m: any, idx: number) => {
          const cargo = m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo || ''
          console.log(`Item ${idx + 1}: cargo="${cargo}", condom√≠nio="${m.st_nome_cond || m.ST_NOME_COND || m.condominio}"`)
        })
        
        // Mostrar todos os cargos √∫nicos encontrados
        const cargosUnicos = new Set(todasListas.map((m: any) => m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo || 'Sem cargo'))
        console.log('Cargos √∫nicos encontrados:', Array.from(cargosUnicos))
      }
      
      // Filtrar apenas cargos que come√ßam com "SI", "S√≠", "s√≠" ou "si"
      // Fun√ß√£o para remover acentos
      const removerAcentos = (str: string): string => {
        return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      }
      
      const isCargoSindico = (cargo: string): boolean => {
        if (!cargo || typeof cargo !== 'string') {
          return false
        }
        // Remover espa√ßos, converter para mai√∫sculas e remover acentos
        const cargoUpper = removerAcentos(cargo.trim().toUpperCase())
        // Verificar se come√ßa com "SI" (sem acento, case-insensitive)
        const comecaComSI = cargoUpper.startsWith('SI')
        return comecaComSI
      }
      
      // Log de debug: mostrar alguns cargos antes do filtro
      const cargosAntesFiltro = todasListas.slice(0, 10).map((m: any) => {
        const cargo = m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo || ''
        return { cargo, passa: isCargoSindico(cargo) }
      })
      console.log('[Mandatos] Exemplos de cargos antes do filtro (primeiros 10):', cargosAntesFiltro)
      
      const todasListasFiltradas = todasListas.filter((m: any) => {
        const cargo = m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo || ''
        const passa = isCargoSindico(cargo)
        return passa
      })
      
      console.log(`[Mandatos] Filtrando cargos que come√ßam com "SI": ${todasListas.length} -> ${todasListasFiltradas.length} itens`)
      
      // Mostrar cargos √∫nicos ap√≥s filtro
      const cargosUnicosFiltrados = new Set(todasListasFiltradas.map((m: any) => m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo || 'Sem cargo'))
      console.log('[Mandatos] Cargos √∫nicos ap√≥s filtro (come√ßam com SI):', Array.from(cargosUnicosFiltrados))
      
      // Verificar se h√° cargos que n√£o deveriam passar
      const cargosInvalidos = todasListasFiltradas.filter((m: any) => {
        const cargo = m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo || ''
        const cargoUpper = removerAcentos(cargo.trim().toUpperCase())
        return !cargoUpper.startsWith('SI')
      })
      if (cargosInvalidos.length > 0) {
        console.error('[Mandatos] ‚ö†Ô∏è ERRO: Encontrados cargos que n√£o come√ßam com "SI" ap√≥s filtro:', cargosInvalidos.slice(0, 5).map((m: any) => m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo))
      }
      
      // An√°lise detalhada dos condom√≠nios (ap√≥s filtro)
      const condominiosUnicosSet = new Set(todasListasFiltradas.map((m: any) => m.st_nome_cond || m.ST_NOME_COND || m.condominio || 'Sem nome'))
      const condominiosComContagem = Array.from(condominiosUnicosSet).map(cond => ({
        nome: cond,
        quantidade: todasListasFiltradas.filter((m: any) => (m.st_nome_cond || m.ST_NOME_COND || m.condominio || 'Sem nome') === cond).length
      }))
      
      console.log('Condom√≠nios √∫nicos encontrados (ap√≥s filtro):', condominiosUnicosSet.size)
      console.log('Distribui√ß√£o por condom√≠nio:', condominiosComContagem)
      
      if (condominiosUnicosSet.size === 1) {
        console.warn('‚ö†Ô∏è ATEN√á√ÉO: Apenas 1 condom√≠nio encontrado! Isso pode indicar:')
        console.warn('  1. A API est√° retornando apenas dados de um condom√≠nio')
        console.warn('  2. H√° um filtro sendo aplicado na API que limita os resultados')
        console.warn('  3. A pagina√ß√£o n√£o est√° funcionando corretamente')
        console.warn('  4. O par√¢metro idCondominio pode estar sendo usado implicitamente')
      }
      
      const mapped: Mandato[] = todasListasFiltradas
        .map((m: any) => {
          // Determinar status baseado nas datas
          let status: 'ativo' | 'encerrado' | 'futuro' = 'ativo'
          
          const dataEntrada = m.dt_entrada_sin ? parseDate(m.dt_entrada_sin) : null
          const dataSaida = m.dt_saida_sin ? parseDate(m.dt_saida_sin) : null
          
          if (dataSaida && dataSaida < hoje) {
            status = 'encerrado'
          } else if (dataEntrada && dataEntrada > hoje) {
            status = 'futuro'
          } else if (dataEntrada && dataEntrada <= hoje && (!dataSaida || dataSaida >= hoje)) {
            status = 'ativo'
          }

          return {
            id: String(m.id_sindico_sin || m.ID_SINDICO_SIN || m.id || Math.random()),
            condominio: m.st_nome_cond || m.ST_NOME_COND || m.condominio || 'N√£o informado',
            nomeFantasia: m.st_fantasia_cond || m.ST_FANTASIA_COND || m.nome_fantasia || m.condominio || 'N√£o informado',
            nomeResponsavel: m.st_nome_sin || m.ST_NOME_SIN || m.nome || 'N√£o informado',
            cargo: m.st_cargo_sin || m.ST_CARGO_SIN || m.cargo || 'N√£o informado',
            dataEntrada: m.dt_entrada_sin || m.DT_ENTRADA_SIN || m.data_entrada || '',
            dataSaida: m.dt_saida_sin || m.DT_SAIDA_SIN || m.data_saida || null,
            email: m.st_email_sin || m.ST_EMAIL_SIN || m.email || '',
            telefone: m.st_telefone_sin || m.ST_TELEFONE_SIN || m.telefone || '',
            celular: m.st_celular_sin || m.ST_CELULAR_SIN || m.celular || '',
            status,
            observacoes: m.st_observacao_sin || m.ST_OBSERVACAO_SIN || m.observacoes || undefined,
          }
        })
        // Ordenar por data de sa√≠da em ordem crescente (nulls por √∫ltimo)
        .sort((a, b) => {
          const dataSaidaA = a.dataSaida ? parseDate(a.dataSaida) : null
          const dataSaidaB = b.dataSaida ? parseDate(b.dataSaida) : null
          
          // Se ambos t√™m data de sa√≠da, ordena crescente (mais antiga primeiro)
          if (dataSaidaA && dataSaidaB) {
            return dataSaidaA.getTime() - dataSaidaB.getTime()
          }
          // Se apenas A tem data, A vem primeiro (antes dos nulls)
          if (dataSaidaA && !dataSaidaB) {
            return -1
          }
          // Se apenas B tem data, B vem primeiro (antes dos nulls)
          if (!dataSaidaA && dataSaidaB) {
            return 1
          }
          // Se nenhum tem data, ordena por data de entrada crescente como fallback
          const dataEntradaA = a.dataEntrada ? parseDate(a.dataEntrada) : null
          const dataEntradaB = b.dataEntrada ? parseDate(b.dataEntrada) : null
          if (dataEntradaA && dataEntradaB) {
            return dataEntradaA.getTime() - dataEntradaB.getTime()
          }
          return 0
        })
      
      // Verifica√ß√£o final: garantir que todos os cargos mapeados come√ßam com "SI"
      const mappedFiltrado = mapped.filter(item => {
        const cargoUpper = removerAcentos((item.cargo || '').trim().toUpperCase())
        const comecaComSI = cargoUpper.startsWith('SI')
        if (!comecaComSI) {
          console.warn(`[Mandatos] ‚ö†Ô∏è Cargo removido no filtro final: "${item.cargo}"`)
        }
        return comecaComSI
      })
      
      console.log(`[Mandatos] Dados mapeados e ordenados: ${mapped.length} -> ${mappedFiltrado.length} itens (apenas cargos que come√ßam com "SI", ordenados por data de sa√≠da)`)
      
      // Log dos cargos √∫nicos no resultado final
      const cargosFinais = new Set(mappedFiltrado.map(m => m.cargo))
      console.log('[Mandatos] Cargos √∫nicos no resultado final:', Array.from(cargosFinais))
      
      // Filtrar duplicatas: manter apenas um s√≠ndico por condom√≠nio
      // Se houver m√∫ltiplos s√≠ndicos para o mesmo condom√≠nio, manter o mais recente e ativo
      // Crit√©rio de prioridade:
      // 1. Data de entrada mais recente (mandato mais atual)
      // 2. Se empate, data de fim mais distante (mandato com maior dura√ß√£o)
      // 3. Se ainda empate, manter o primeiro encontrado
      const condominiosUnicos = new Map<string, Mandato>()
      
      // Fun√ß√£o para normalizar nome do condom√≠nio (remover espa√ßos extras, converter para mai√∫sculas)
      // Tamb√©m remove prefixos comuns como "CONDOM√çNIO", "RESIDENCIAL", n√∫meros iniciais, etc.
      const normalizarNomeCondominio = (nome: string): string => {
        let normalizado = nome.trim().replace(/\s+/g, ' ').toUpperCase()
        // Remover prefixos comuns
        normalizado = normalizado.replace(/^(CONDOM√çNIO|CONDOMINIO|RESIDENCIAL|EDIF√çCIO|EDIFICIO)\s+/i, '')
        // Remover n√∫meros iniciais (como "156 VILLA TOSCANA" -> "VILLA TOSCANA")
        normalizado = normalizado.replace(/^\d+\s+/, '')
        return normalizado.trim()
      }
      
      mappedFiltrado.forEach((mandato) => {
        const nomeCondominioNormalizado = normalizarNomeCondominio(mandato.condominio)
        const mandatoExistente = condominiosUnicos.get(nomeCondominioNormalizado)
        
        if (!mandatoExistente) {
          // Primeira ocorr√™ncia deste condom√≠nio
          condominiosUnicos.set(nomeCondominioNormalizado, mandato)
        } else {
          // J√° existe um mandato para este condom√≠nio - decidir qual manter
          const dataEntradaAtual = mandato.dataEntrada ? parseDate(mandato.dataEntrada) : null
          const dataEntradaExistente = mandatoExistente.dataEntrada ? parseDate(mandatoExistente.dataEntrada) : null
          const dataFimAtual = mandato.dataSaida ? parseDate(mandato.dataSaida) : null
          const dataFimExistente = mandatoExistente.dataSaida ? parseDate(mandatoExistente.dataSaida) : null
          
          let deveSubstituir = false
          let motivo = ''
          
          if (dataEntradaAtual && dataEntradaExistente) {
            // Comparar por data de entrada (mais recente = melhor)
            if (dataEntradaAtual.getTime() > dataEntradaExistente.getTime()) {
              deveSubstituir = true
              motivo = `data entrada mais recente (${mandato.dataEntrada} vs ${mandatoExistente.dataEntrada})`
            } else if (dataEntradaAtual.getTime() === dataEntradaExistente.getTime()) {
              // Se datas de entrada s√£o iguais, comparar por data de fim (mais distante = melhor)
              if (dataFimAtual && dataFimExistente) {
                if (dataFimAtual.getTime() > dataFimExistente.getTime()) {
                  deveSubstituir = true
                  motivo = `data fim mais distante (${mandato.dataSaida} vs ${mandatoExistente.dataSaida})`
                }
              } else if (dataFimAtual && !dataFimExistente) {
                // Atual tem data de fim, existente n√£o - preferir atual
                deveSubstituir = true
                motivo = 'existente n√£o tem data de fim'
              }
            }
          } else if (dataEntradaAtual && !dataEntradaExistente) {
            // Mandato atual tem data, existente n√£o tem - substituir
            deveSubstituir = true
            motivo = 'existente n√£o tem data de entrada'
          }
          
          if (deveSubstituir) {
            condominiosUnicos.set(nomeCondominioNormalizado, mandato)
            console.log(`[Mandatos] Substituindo s√≠ndico do condom√≠nio "${mandato.condominio}" (${motivo})`)
            console.log(`[Mandatos]   Antigo: ${mandatoExistente.nomeResponsavel} (${mandatoExistente.dataEntrada} - ${mandatoExistente.dataSaida || 'sem fim'})`)
            console.log(`[Mandatos]   Novo: ${mandato.nomeResponsavel} (${mandato.dataEntrada} - ${mandato.dataSaida || 'sem fim'})`)
          }
        }
      })
      
      const mandatosUnicos = Array.from(condominiosUnicos.values())
      console.log(`[Mandatos] Removendo duplicatas: ${mappedFiltrado.length} -> ${mandatosUnicos.length} mandatos √∫nicos (um por condom√≠nio)`)
      
      // Log de condom√≠nios √∫nicos
      const nomesCondominios = mandatosUnicos.map(m => m.condominio)
      console.log(`[Mandatos] ‚úÖ Condom√≠nios √∫nicos encontrados: ${nomesCondominios.length}`)
      if (nomesCondominios.length > 0 && nomesCondominios.length <= 10) {
        console.log('[Mandatos] Lista de condom√≠nios:', nomesCondominios)
      } else if (nomesCondominios.length > 10) {
        console.log('[Mandatos] Primeiros 10 condom√≠nios:', nomesCondominios.slice(0, 10))
        console.log('[Mandatos] √öltimos 10 condom√≠nios:', nomesCondominios.slice(-10))
      }
      
      if (mandatosUnicos.length === 0) {
        console.error('[Mandatos] ‚ö†Ô∏è ATEN√á√ÉO: Nenhum mandato √∫nico encontrado ap√≥s remo√ß√£o de duplicatas!')
        console.error('[Mandatos] Dados antes da remo√ß√£o de duplicatas:', mappedFiltrado.length, 'itens')
        if (mappedFiltrado.length > 0) {
          console.error('[Mandatos] Primeiros 5 itens antes da remo√ß√£o:', mappedFiltrado.slice(0, 5).map(m => ({
            condominio: m.condominio,
            responsavel: m.nomeResponsavel,
            cargo: m.cargo
          })))
        }
      }
      
      console.log('[Mandatos] ========== FINALIZANDO CARREGAMENTO ==========')
      console.log('[Mandatos] Definindo', mandatosUnicos.length, 'mandatos √∫nicos no estado')
      
      // Se n√£o encontrou nenhum mandato, verificar se foi por erro de autentica√ß√£o
      // S√≥ mostrar modal se realmente houver erro 401/403, n√£o apenas por falta de dados
      if (mandatosUnicos.length === 0 && tokenExpiredRef.current) {
        console.log('[Mandatos] Nenhum mandato encontrado. Verificando se foi por erro de autentica√ß√£o...')
        // N√£o mostrar modal automaticamente - deixar o erro ser tratado no catch
        setData([])
        return
      }
      
      setData(mandatosUnicos)
  } catch (e: any) {
    let errorMessage = e?.message || String(e)
    
    // Melhorar mensagens de erro comuns
    if (errorMessage.includes('Failed to fetch') || errorMessage.includes('NetworkError')) {
      errorMessage = 'Erro de conex√£o: N√£o foi poss√≠vel conectar ao servidor. Verifique sua conex√£o ou se o servidor est√° rodando.'
      setErro(errorMessage)
    } else if (errorMessage.includes('Timeout')) {
      errorMessage = 'Timeout: A requisi√ß√£o demorou muito para responder.\n\n' +
        'Poss√≠veis causas:\n' +
        '‚Ä¢ A API est√° lenta ou sobrecarregada\n' +
        '‚Ä¢ Problemas de conex√£o com o servidor\n' +
        '‚Ä¢ A empresa selecionada pode n√£o ter dados ou ter muitos registros\n\n' +
        'Tente:\n' +
        '‚Ä¢ Selecionar outra empresa no seletor do topo\n' +
        '‚Ä¢ Verificar sua conex√£o com a internet\n' +
        '‚Ä¢ Tentar novamente em alguns instantes'
      setErro(errorMessage)
    } else if (errorMessage.includes('401') || errorMessage.includes('expirado') || errorMessage.includes('expired') || errorMessage.includes('Unauthorized') || errorMessage.includes('login') || errorMessage.includes('autentica√ß√£o')) {
      // Erro de autentica√ß√£o
      console.log('[Mandatos] Erro de autentica√ß√£o detectado')
      tokenExpiredRef.current = true
      setErro('Token de autentica√ß√£o expirado ou inv√°lido. Execute: cd /home/luizmassa/PROJETOS/iap-apps && ./iap auth')
      setData([])
      return
    } else if (errorMessage.includes('403') || errorMessage.includes('Permiss√£o') || errorMessage.includes('permiss√£o')) {
      errorMessage = 'Acesso negado: Voc√™ n√£o tem permiss√£o para acessar este recurso.\n\n' + 
        (errorMessage.includes('abimoveis') ? 'Tente selecionar outra empresa no seletor no topo da p√°gina.' : '')
      setErro(errorMessage)
      setData([]) // Definir dados vazios para n√£o quebrar
    } else if (errorMessage.includes('404')) {
      errorMessage = 'Recurso n√£o encontrado (404): O endpoint n√£o existe ou foi movido.'
      setErro(errorMessage)
      setData([]) // Definir dados vazios para n√£o quebrar
    } else {
      setErro(errorMessage)
      setData([]) // Definir dados vazios para n√£o quebrar
    }
    
    console.error('Erro ao carregar mandatos:', e)
    // IMPORTANTE: N√£o relan√ßar a exce√ß√£o para evitar que o React Router mostre a p√°gina de erro gen√©rica
  } finally {
    setLoading(false)
    loadingRef.current = false
  }
}

  // Fun√ß√£o auxiliar para parse de datas
  const parseDate = (dateString: string): Date | null => {
    if (!dateString) return null
    try {
      // Formato esperado: "01/01/2018 00:00:00" ou "01/01/2018" (DD/MM/YYYY)
      const parts = dateString.trim().split(' ')
      const datePart = parts[0]
      const dateParts = datePart.split('/')
      
      if (dateParts.length === 3) {
        // DD/MM/YYYY (formato brasileiro)
        const dia = parseInt(dateParts[0], 10)
        const mes = parseInt(dateParts[1], 10) - 1 // M√™s √© 0-indexed em Date
        const ano = parseInt(dateParts[2], 10)
        
        // Validar se os valores s√£o v√°lidos
        if (isNaN(dia) || isNaN(mes) || isNaN(ano)) return null
        if (dia < 1 || dia > 31 || mes < 0 || mes > 11 || ano < 1900 || ano > 2100) return null
        
        return new Date(ano, mes, dia)
      }
      
      // Tentar parse direto
      const date = new Date(dateString)
      if (isNaN(date.getTime())) return null
      return date
    } catch {
      return null
    }
  }

  // Filtrar apenas mandatos ativos (n√£o mostrar encerrados)
  const filteredData = data
    .filter(item => item.status === 'ativo') // Apenas ativos
    .filter(item => {
      const matchesSearch = !searchTerm || 
        item.condominio.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.nomeResponsavel.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.cargo.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.email.toLowerCase().includes(searchTerm.toLowerCase())
      
      return matchesSearch
    })
    // Ordenar conforme sele√ß√£o do usu√°rio
    .sort((a, b) => {
      if (ordenacao === 'nome') {
        // Ordenar por nome do condom√≠nio (A-Z)
        return a.condominio.localeCompare(b.condominio, 'pt-BR', { sensitivity: 'base' })
      } else {
        // Ordenar por data de fim (Sa√≠da) em ordem crescente
        // Vencidos aparecem primeiro (datas passadas), depois pr√≥ximos a vencer
        const dataFimA = a.dataSaida ? parseDate(a.dataSaida) : null
        const dataFimB = b.dataSaida ? parseDate(b.dataSaida) : null
        
        // Se ambos t√™m data de fim, ordena crescente (vencimentos mais pr√≥ximos primeiro)
        // Datas passadas (vencidas) ter√£o valores menores e aparecer√£o primeiro
        if (dataFimA && dataFimB) {
          return dataFimA.getTime() - dataFimB.getTime()
        }
        // Se apenas A tem data, A vem primeiro (antes dos sem data)
        if (dataFimA && !dataFimB) {
          return -1
        }
        // Se apenas B tem data, B vem primeiro (antes dos sem data)
        if (!dataFimA && dataFimB) {
          return 1
        }
        // Se nenhum tem data, ordena por data de in√≠cio como fallback
        const dataInicioA = a.dataEntrada ? parseDate(a.dataEntrada) : null
        const dataInicioB = b.dataEntrada ? parseDate(b.dataEntrada) : null
        if (dataInicioA && dataInicioB) {
          return dataInicioA.getTime() - dataInicioB.getTime()
        }
        return 0
      }
    })

  const getStatusBadge = (status: string) => {
    const styles = {
      ativo: "bg-green-100 text-green-800",
      encerrado: "bg-gray-100 text-gray-800",
      futuro: "bg-blue-100 text-blue-800"
    }
    return (
      <span className={`inline-flex items-center px-1.5 py-0.5 rounded-full text-xs font-medium ${styles[status as keyof typeof styles] || 'bg-gray-100 text-gray-800'}`}>
        {status.charAt(0).toUpperCase() + status.slice(1)}
      </span>
    )
  }

  const formatDate = (dateString: string | null) => {
    if (!dateString) return '-'
    try {
      const date = parseDate(dateString)
      if (!date) return dateString
      // Formatar no formato brasileiro: dd/mm/aaaa
      const dia = String(date.getDate()).padStart(2, '0')
      const mes = String(date.getMonth() + 1).padStart(2, '0')
      const ano = date.getFullYear()
      return `${dia}/${mes}/${ano}`
    } catch {
      return dateString
    }
  }

  // Calcular dias at√© vencimento do mandato
  const calcularDiasAteVencimento = (dataFim: string | null): number | null => {
    if (!dataFim) return null
    const hoje = new Date()
    hoje.setHours(0, 0, 0, 0)
    const fim = parseDate(dataFim)
    if (!fim) return null
    fim.setHours(0, 0, 0, 0)
    const diffTime = fim.getTime() - hoje.getTime()
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
    return diffDays
  }

  // Determinar estilo da linha baseado no status do mandato
  const getRowStyle = (item: Mandato): string => {
    const diasAteVencimento = calcularDiasAteVencimento(item.dataSaida)
    
    if (diasAteVencimento === null) {
      // Sem data de fim - estilo normal
      return 'border-b border-gray-200 hover:bg-gray-50'
    }
    
    if (diasAteVencimento < 0) {
      // Mandato vencido - vermelho negrito
      return 'border-b border-gray-200 bg-red-50 hover:bg-red-100 font-bold text-red-900'
    } else if (diasAteVencimento <= 60) {
      // At√© 60 dias para vencer - amarelo negrito
      return 'border-b border-gray-200 bg-yellow-50 hover:bg-yellow-100 font-bold text-yellow-900'
    }
    
    // Mais de 60 dias - estilo normal
    return 'border-b border-gray-200 hover:bg-gray-50'
  }

  // Obter texto da previs√£o de elei√ß√£o
  const getPrevisaoEleicao = (item: Mandato): string => {
    const diasAteVencimento = calcularDiasAteVencimento(item.dataSaida)
    
    if (diasAteVencimento === null) {
      return '-'
    }
    
    if (diasAteVencimento < 0) {
      return `Vencido h√° ${Math.abs(diasAteVencimento)} dia(s)`
    }
    
    if (diasAteVencimento <= 30) {
      return `‚ö†Ô∏è ${diasAteVencimento} dia(s) - ALERTA`
    }
    
    if (diasAteVencimento <= 60) {
      return `${diasAteVencimento} dia(s)`
    }
    
    return `${diasAteVencimento} dia(s)`
  }


  return (
    <div className="space-y-6">
      <div className="bg-white shadow rounded-lg p-6">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-2xl font-bold text-gray-900">Mandatos - Respons√°veis Legais</h1>
          <span className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">v1.0.1</span>
        </div>
        
        {/* Mensagem de erro */}
        {erro && (
          <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg">
            <p className="text-red-800 text-sm font-semibold mb-2">Erro ao carregar mandatos:</p>
            <p className="text-red-700 text-sm mb-3 whitespace-pre-line">{erro}</p>
            {erro.includes('expirado') || erro.includes('expired') ? (
              <div className="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded">
                <p className="text-yellow-800 text-xs font-semibold mb-1">Como renovar o token:</p>
                <code className="block text-xs bg-gray-100 p-2 rounded mb-2">./iap auth</code>
                <p className="text-yellow-700 text-xs">Execute este comando no terminal e depois recarregue a p√°gina.</p>
              </div>
            ) : (
              <p className="text-red-600 text-xs mb-2">Verifique o console do navegador (F12) para mais detalhes.</p>
            )}
            <button
              onClick={() => {
                tokenExpiredRef.current = false
                carregarMandatos()
              }}
              className="mt-2 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 text-sm"
            >
              Tentar novamente
            </button>
          </div>
        )}

        {/* Loading */}
        {loading && (
          <div className="mb-4 p-4 text-center">
            <p className="text-gray-600">Carregando mandatos...</p>
          </div>
        )}
        
        {/* Filtros */}
        <div className="mb-4">
          <div className="flex flex-wrap gap-4 items-end">
            <div className="flex-1 min-w-[200px]">
              <label className="block text-xs font-medium text-gray-700 mb-1">Buscar</label>
              <input
                type="text"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                placeholder="Buscar por condom√≠nio, nome, cargo..."
                className="border border-gray-300 rounded px-2 py-1.5 text-xs w-full focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1">Ordenar por</label>
              <div className="flex gap-2">
                <button
                  onClick={() => setOrdenacao('vencimento')}
                  className={`px-3 py-1.5 text-xs rounded border transition-colors ${
                    ordenacao === 'vencimento'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                >
                  Vencimento
                </button>
                <button
                  onClick={() => setOrdenacao('nome')}
                  className={`px-3 py-1.5 text-xs rounded border transition-colors ${
                    ordenacao === 'nome'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                >
                  Nome
                </button>
              </div>
            </div>
          </div>
        </div>

        <div className="text-xs text-gray-600 mb-2">
          {filteredData.length} mandato(s) encontrado(s) de {data.filter(item => item.status === 'ativo').length} condom√≠nio(s) ativo(s)
        </div>

        {/* Tabela */}
        {!loading && !erro && filteredData.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            Nenhum mandato encontrado.
          </div>
        )}
        
        {!loading && filteredData.length > 0 && (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-xs">
            <thead className="bg-gray-50">
              <tr>
                <th className="border-b border-gray-300 px-2 py-1 text-center font-semibold text-gray-700 text-xs w-12">#</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Condom√≠nio</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Respons√°vel</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Cargo</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">In√≠cio</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Fim</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Previs√£o de Elei√ß√£o</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Email</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Telefone</th>
                <th className="border-b border-gray-300 px-2 py-1 text-left font-semibold text-gray-700 text-xs">Status</th>
              </tr>
            </thead>
            <tbody>
              {filteredData.map((item, index) => {
                const diasAteVencimento = calcularDiasAteVencimento(item.dataSaida)
                const isVencido = diasAteVencimento !== null && diasAteVencimento < 0
                const isAte60Dias = diasAteVencimento !== null && diasAteVencimento >= 0 && diasAteVencimento <= 60
                
                return (
                  <tr key={item.id} className={getRowStyle(item)}>
                    <td className="border-b border-gray-200 px-2 py-1 text-center text-xs text-gray-500">{index + 1}</td>
                    <td className="border-b border-gray-200 px-2 py-1 font-medium text-xs whitespace-nowrap overflow-hidden text-ellipsis max-w-xs" title={item.condominio}>{item.condominio}</td>
                    <td className="border-b border-gray-200 px-2 py-1 text-xs">{item.nomeResponsavel}</td>
                    <td className="border-b border-gray-200 px-2 py-1 text-xs">{item.cargo}</td>
                    <td className="border-b border-gray-200 px-2 py-1 text-xs">{formatDate(item.dataEntrada)}</td>
                    <td className="border-b border-gray-200 px-2 py-1 text-xs">{formatDate(item.dataSaida)}</td>
                    <td className={`border-b border-gray-200 px-2 py-1 text-xs ${isVencido ? 'text-red-700 font-bold' : isAte60Dias ? 'text-yellow-700 font-bold' : ''}`}>
                      {getPrevisaoEleicao(item)}
                    </td>
                    <td className="border-b border-gray-200 px-2 py-1 text-xs">{item.email || '-'}</td>
                    <td className="border-b border-gray-200 px-2 py-1 text-xs">
                      {item.celular || item.telefone || '-'}
                    </td>
                    <td className="border-b border-gray-200 px-2 py-1 text-xs">{getStatusBadge(item.status)}</td>
                  </tr>
                )
              })}
            </tbody>
          </table>
        </div>
        )}
      </div>
      
      {/* Rodap√© */}
      <div className="mt-4 pt-3 border-t border-gray-200 flex items-center justify-between text-xs text-gray-500">
        <div className="flex items-center gap-2">
          <span className="text-lg font-bold">Œª</span>
          <span className="font-medium">assa</span>
        </div>
        <div>
          {filteredData.length} mandato(s) encontrado(s)
        </div>
      </div>
    </div>
  )
}

